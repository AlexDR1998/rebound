/* double coefficient_of_restitution_bridges(double v){ */
/* 	// assumes v in units of [m/s] */
/* 	double eps = 0.32*pow(fabs(v)*100.,-0.234); */
/* 	if (eps>1) eps=1; */
/* 	if (eps<0) eps=0; */
/* 	return eps; */
/* } */


/* void cl_collision_resolve_hardsphere( */
/* 				     float body1_x, */
/* 				     float body1_y, */
/* 				     float body1_z, */
/* 				     float body1_vx, */
/* 				     float body1_vy, */
/* 				     float body1_vz, */
/* 				     float body1_mass, */
/* 				     float body2_x, */
/* 				     float body2_y, */
/* 				     float body2_z, */
/* 				     float body2_vx, */
/* 				     float body2_vy, */
/* 				     float body2_vz, */
/* 				     float body2_mass, */
/* 				     int gbx, */
/* 				     int gby, */
/* 				     int gbz, */
/* 				     float minimum_collision_velocity */
/* 				     ){ */

/*   float shiftx, shifty, shiftz, shiftvx, shiftvy, shiftvz; */
/*   cl_boundaries_get_ghostbox(gbx,gby,gbz, shiftx, shifty, shiftz, shiftvx, shiftvy, shiftvz); */
  
/*   float x21 = p1.x + gb.shiftx - p2.x; */
/*   float y21 = p1.y + gb.shifty - p2.y; */
/*   float z21 = p1.z + gb.shiftz - p2.z; */

/*   float vx21 = p1.vx + gb.shiftvx - p2.vx; */
/*   float vy21 = p1.vy + gb.shiftvy - p2.vy; */
/*   float vz21 = p1.vz + gb.shiftvz - p2.vz; */

/*   float angle1 = atan2(z21, y21); */
/*   float sin_angle1 = sin(angle1); */
/*   float cos_angle1 = cos(angle1); */
/*   float vy21n = cos_angle1 * vy21 + sin_angle1 * vz21; */
/*   float y21n = cos_angle1 * y21 + sin_angle1 * z21; */

/*   float angle2 = atan2(y21n, x21); */
/*   float cos_angle2 = cos(angle2); */
/*   float sin_angle2 = sin(angle2); */
/*   float vx21nn = cphi * vx21 + sphi * vy21n; */

/*   float dvx2 = -(1.f + coefficient_of_restitution)*vx21nn; */
/*   float minr = (p1.r > p2.r)?p2.r:p1.r; */
/*   float maxr = (p1.r > p2.r)?p2.r:p1.r; */
/*   float mindv = minr*minimum_collision_velocity; */
/*   float r = sqrt(x21*x21 + y21*y21 + z21*z21); */

/*   mindv *= 1.-(r-maxr)/minr; */
/*   if (mindv > maxr*minimum_collision_velocity) */
/*     mindv = maxr*minimum_collision_velocity; */
/*   if (dvx2 < mindv) */
/*     dvx2 = mindv; */
  
/*   float dvx2n = cos_angle2 * dvx2; */
/*   float dvy2n = sin_angle2 * dvx2; */
/*   float dvy2nn = cos_angle1 * dvy2n; */
/*   float dvz2nn = sin_angle1 * dvy2n; */

/*   float prefactor = body1_mass/(body1_mass + body2_mass); */
/*   vx_dev[p2] -= prefactor*dvx2n; */
/*   vy_dev[p2] -= prefactor*dvy2nn; */
/*   vz_dev[p2] -= prefactor*dvz2nn; */

/*   prefactor = body2_mass(body1_mass + body2_mass); */
/*   vx_dev[p2] += prefactor*dvx2n; */
/*   vy_dev[p2] += prefactor*dvy2nn; */
/*   vz_dev[p2] += prefactor*dvz2nn; */

/* } */

/* __kernel void cl_collisions_resolve(  */
/* 				    __global float* x_dev,  */
/* 				    __global float* y_dev, */
/* 				    __global float* z_dev, */
/* 				    __global float* vx_dev, */
/* 				    __global float* vy_dev, */
/* 				    __global float* vz_dev, */
/* 				    __global float* mass_dev, */
/* 				    __constant int* num_bodies_dev, */
/* 				    __constant float* coefficient_of_restitution, */
/* 				    __constant float* minimum_collision_velocity */
/* 				     ) */

/* { */
/*   // the two bodies in the collision */
/*   int body1,body2; */
/*   int gbx_offset = *num_bodies_dev; */
/*   int gby_offset = gbx_offset*3; */
/*   int gbz_offset = gby_offset*3; */

/*   for (body1 = local_id(0) + get_group_id(0)*get_local_size(0) ; body1 < *num_bodies_dev; body1 += get_global_size(0)){ */
/*     for (int gbx = -1; gbx <= 1; gbx++){ */
/*       for (int gby = -1; gby <= 1; gby++){ */
/* 	for (int gbz = -1; gbz <= 1; gbz++){ */
/* 	  body2 = collisions[i + gbx_offset*(gbx+1) + gby_offset*3*(gby+1) + gbz_offset*9*(gbz+1)]; */
/* 	  // body2 = -1 -> no collision */
/* 	  // body2 = body1 -> same particle */
/* 	  // body2 < body1 -> another thread is already working on this collision or will be working on it (ASSUMPTION: only collisions between *pairs* of particles occur) */
/* 	  // body2 > body1 -> collision not resolved, fix this */
/* 	  if ( body2 > body1)   */
/* 	    collision_resolve(x_dev[body1],  */
/* 			      y_dev[body1],  */
/* 			      z_dev[body1],  */
/* 			      vx_dev[body1],  */
/* 			      vy_dev[body1],  */
/* 			      vz_dev[body1],  */
/* 			      mass_dev[body1], */
/* 			      x_dev[body2],  */
/* 			      y_dev[body2],  */
/* 			      z_dev[body2],  */
/* 			      vx_dev[body2],  */
/* 			      vy_dev[body2],  */
/* 			      vz_dev[body2],  */
/* 			      mass_dev[body2], */
/* 			      gbx,  */
/* 			      gby,  */
/* 			      gbz, */
/* 			      coefficient_of_restituion, */
/* 			      minimum_collision_velocity); */
/* 	} */
/*       } */
/*     } */
/*   } */
/* } */


__kernel void cl_collision_search( 
				    __global float* x_dev, 
				    __global float* y_dev,
				    __global float* z_dev,
				    __global float* vx_dev,
				    __global float* vy_dev,
				    __global float* vz_dev,
				    __global float* mass_dev,
				    __global int* sort_dev,
				    __global int* collisions_dev,
				    __global int* children_dev,
				    __global int* maxdepth_dev,
				    __constant float* boxsize_dev,
				    __constant int* num_nodes_dev, 
				    __constant int* num_bodies_dev,
				    __local int* children_local, 
				    __local int* pos_local,
				    __local int* node_local,
				    __local float* dr_cutoff_local,
				    __local float* nodex_local,
				    __local float* nodey_local,
				    __local float* nodez_local,
				    __local float* nodem_local,
				    __local float* noderad_local,
				    __local int* wavefront_vote_local,){
  
  int i, j, k,l, node, depth, base, sbase, diff, local_id;
  float body_x, body_y, body_z, dx, dy, dz, temp_register;
  __local int maxdepth_local;

  int gbx_offset = *num_bodies_dev;
  int gby_offset = gbx_offset*3;
  int gbz_offset = gby_offset*3;

  local_id = get_local_id(0);

  if (local_id == 0){
    maxdepth_local = *maxdepth_dev;
    dr_cutoff_local[0] = *boxsize_dev*0.86602540378443;
    for (i = 1; i < maxdepth_local; i++){
      dr_cutoff_local[i] = dr_cutoff_local[i-1] * .5f;
      dr_cutoff_local[i-1] += collisions_max2_r_dev; 
    }
#ifdef ERROR_CHECK
    if (maxdepth_local > MAXDEPTH){
    *error_dev = -2;
  }
#endif
  }

  barrier(CLK_LOCAL_MEM_FENCE);

  if (maxdepth_local <= MAX_DEPTH){
    base = local_id / WAVEFRONT_SIZE;
    sbase = base * WAVEFRONT_SIZE;
    j = base * MAX_DEPTH;
  
    diff = local_id - sbase;
    if (diff < MAX_DEPTH){
      dr_cutoff_local[diff + j] = dr_cutoff_local[diff];
    }
    barrier(CLK_LOCAL_MEM_FENCE);

    //potential optomization: replace these with stored register variables
    for (k = local_id + get_group_id(0)*get_local_size(0); k < *num_bodies_dev; k += get_global_size(0)){

      i = sort_dev[k];
      body_x = x_dev[i];
      body_y = y_dev[i];
      body_z = z_dev[i];

      for (gbx = -1; gbx <= 1; gbx++){
	for (gby = -1; gby <= 1; gby++){
	  for (gbz = -1; gbz <= 1; gbz++){
    
	    //send shifts to function as pointers, get rid of struct
	    boundaries_get_ghostbox(gbx,gby,gbz,shiftx,shifty,shiftz,shiftvx,shiftvy,shiftvz);

	    depth = j;
	    //first thread in wavefront leads
	    if (sbase == local_id){
	      node_local[j] = *num_nodes_dev;
	      pos_local[j] = 0;
	    }
	    mem_fence(CLK_LOCAL_MEM_FENCE);

	    //initialize collisions array
	    collisions[i + gbx_offset*(gbx+1) + gby_offset*3*(gby+1) + gbz_offset*9*(gbz+1)] = -1; 

	    while (depth >= j){
	      while(pos_local[depth] < 8){
		//first thread in wavefront leads
		if(sbase == local_id){
		  node = children_dev[node_local[depth]*8 + pos_local[depth]];
		  pos_local[depth]++;
		  children_local[base] = node;
		  if (node >= 0 && node < *num_bodies_dev){
		    //MIGHT CHANGE TO THIS TO NODE >= 0 && NODE < NUM_BODIES?
		    nodex_local[base] = x_dev[node];
		    nodey_local[base] = y_dev[node];
		    nodez_local[base] = z_dev[node];
		    noderad_local[base] = rad_dev[node];
		    nodem_local[base] = mass_dev[node];
		  }
		}
		mem_fence(CLK_LOCAL_MEM_FENCE);
		node = children_local[base];
		if (node >= 0){

		  dx = (body_x + shiftx) - nodex_local[base];
		  dy = (body_y + shifty) - nodey_local[base];
		  dz = (body_z + shiftz) - nodez_local[base];
		  temp_register = dx*dx + dy*dy + dz*dz;
		  
 		  // if it's a leaf cell
		  if (node < *num_bodies_dev) 
		    {
		      //if the node isn't the body check for a collision 
		      if (node != i){
			rp = body_rad_dev + noderad_local[base];
			float dvx = (body_vx + shiftvx) - nodevx_local[base]; 
			float dvy = (body_vy + shiftvy) - nodevy_local[base];
			float dvz = (body_vz + shiftvz) - nodevz_local[base];        	
			if ( temp_register <= rp && dvx*dx + dvy*dy + dvz*dz >0){	  
			  collisions[i + gbx_offset*(gbx+1) + gby_offset*3*(gby+1) + gbz_offset*9*(gbz+1)] = node; 
			}
		      }
		    }
		  
		  else{
		    wavefront_vote_local[local_id] = (temp_register >=  body_radius_dev + dr_cutoff_local[depth]) ? 1 : 0;
		    
		    if (local_id == sbase)
		      for(l = 1; l < WAVEFRONT_SIZE; l++)
			wavefront_vote_local[sbase] += wavefront_vote_local[sbase + l];
		    mem_fence(CLK_LOCAL_MEM_FENCE);
		    
		    //the warp votes whether or not to descend. If one member of the warp votes descend, the
		    //warp descends
		    if (wavefront_vote_local[sbase] < WARP_SIZE){
		      depth++;
		      if(sbase == local_id){
			node_local[depth] = node;
			pos_local[depth] = 0;
		      }
		      mem_fence(CLK_LOCAL_MEM_FENCE);
		    }
		  }
		}

		//if child is null then remaining children of this node is null so move back up the tree
		else{
		  depth = max(j, depth - 1);
		}
	      }
	      depth--;
	    }
	  }
	}
      }
    }
  }
}
