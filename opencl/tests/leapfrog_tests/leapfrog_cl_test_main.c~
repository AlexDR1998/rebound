#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <rand

#ifdef MAC
#include <OpenCL/cl.h>
#else
#include <CL/cl.h>
#endif

#define PROGRAM_FILE "cl_leapfrog_integrator.cl"
#define KERNEL_1 "cl_leapfrog_integrator_part1"
#define KERNEL_2 "cl_leapfrog_integrator_part2"
#define N 32768

int main(int argc, char *argv[])
{
  cl_device_id device;
  cl_context context;
  cl_program program;
  cl_kernel leapfrog_1;
  cl_kernel leapfrog_2;
  cl_command_queue queue;
  cl_int i, error, local_size, global_size;
 
  cl_mem x_buffer;
  cl_mem y_buffer;
  cl_mem z_buffer;
  cl_mem vx_buffer;
  cl_mem vy_buffer;
  cl_mem vz_buffer; 
 
  float dt = .001;
  float x[N];
  float y[N];
  float z[N];  
  float vx[N];
  float vy[N};
  float vz[N];
  
  srand(time(NULL));
  for (i = 0; i < N; i++) {
    x[i]= random_float();
    y[i]= random_float();
    z[i]= random_float();
    vx[i]= random_float();
    vy[i]= random_float();
    vz[i]= random_float();
  }

  device = create_device();
  error = clGetDeviceInfo(device, CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(local_size), &local_size, NULL);
  if (error < 0) {
    perror("Couldn't create a CL context");
    exit(EXIT_FAILURE);
  }

  program - build_program(context, device, PROGRAM_FILE);
  
  // Create buffers
  x_buffer = clCreateBuffer(context, CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR, N * sizeof(float), x, &error)
  y_buffer = clCreateBuffer(context, CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR, N * sizeof(float), y, &error);
  z_buffer = clCreateBuffer(context, CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR, N * sizeof(float), z, &error);
  vx_buffer = clCreateBuffer(context, CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR, N * sizeof(float), vx, &error);
  vy_buffer = clCreateBuffer(context, CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR, N * sizeof(float), vy, &error);
  vz_buffer = clCreateBuffer(context, CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR, N * sizeof(float), vz, &error);
 
  if (error < 0) {
    perror("Couldn't create a CL buffer");
    exit(EXIT_FAILURE);
  }

  //Create a command queue
  queue = clCreateCommandQueue(context, device, CL_QUEUE_PROFILING_ENABLE, &err);
  if (err < 0){
    perror("Couldn't create a command queue");
    exit(EXIT_FAILURE);
  };

  //Create kernels
  leapfrog_1 = clCreateKernel(program, KERNEL_1, &err);
  leapfrog_2 = clCreateKernel(program, KERNEL_2, &err);
  if (err < 0){
    perror("Couldn't create a kernel");
    exit(EXIT_FAILURE);
  }

  error = clSetKernelArg(leapfrog_1, 0, sizeof(cl_mem), &x_buffer);
  error |= clSetKernelArg(leapfrog_1, 1, sizeof(cl_mem), &y_buffer);
  error |= clSetKernelArg(leapfrog_1, 2, sizeof(cl_mem), &z_buffer);
  error |= clSetKernelArg(leapfrog_1, 3, sizeof(cl_mem), &vx_buffer);
  error |= clSetKernelArg(leapfrog_1, 4, sizeof(cl_mem), &vy_buffer);
  error |= clSetKernelArg(leapfrog_1, 5, sizeof(cl_mem), &vz_buffer);
  error |= clSetKernelArg(leapfrog_1, 6, sizeof(dt), &dt);

  error = clSetKernelArg(leapfrog_2, 0, sizeof(cl_mem), &x_buffer);
  error |= clSetKernelArg(leapfrog_2, 1, sizeof(cl_mem), &y_buffer);
  error |= clSetKernelArg(leapfrog_2, 2, sizeof(cl_mem), &z_buffer);
  error |= clSetKernelArg(leapfrog_2, 3, sizeof(cl_mem), &vx_buffer);
  error |= clSetKernelArg(leapfrog_2, 4, sizeof(cl_mem), &vy_buffer);
  error |= clSetKernelArg(leapfrog_2, 5, sizeof(cl_mem), &vz_buffer);
  error |= clSetKernelArg(leapfrog_2, 6, sizeof(dt), &dt);

  if (error < 0) {
    perror("Couldn't create a kernel argument");
    exit(EXIT_FAILURE);
  }

  // Enqueue kernels
  err = clEnqueueNDRangeKernel(queue, leapfrog_1, 1, &global_size, &local_size, 0, NULL, &start_event);
  err |= clEnqueueNDRangeKernel(queue, leapfrog_2, 1, &global_size, &local_size, NULL, &end_event);s

												     
												     
												     
												     
												     
											     // Finish processing the queue and get profiling information
  clFinish(queue);
  clGetEventProfilingInfo(start_event, CL_PROFILING_COMMAND_START,
			  sizeof(time_start), &time_start, NULL);
  clGetEventProfilingInfo(end_event, CL_PROFILING_COMMAND_END,
			  sizeof(time_end), &time_end, NULL);
  total_time = time_end - time_start;

  
  /* Read the result */
  error = clEnqueueReadBuffer(queue, x_buffer, CL_TRUE, 0, sizeof(cl_mem), x, 0, NULL, NULL);
  error = clEnqueueReadBuffer(queue, y_buffer, CL_TRUE, 0, sizeof(cl_mem), y, 0, NULL, NULL);

  if(err < 0) {
    perror("Couldn't read the buffer");
    exit(1);   
  } 
  
  //Set arguments for kernels
  

  return 0;
}
